<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¸…é™¤åŠŸèƒ½è¨ºæ–·å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ffa500);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .content {
            padding: 30px;
        }

        .test-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
            margin-bottom: 20px;
        }

        .test-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .test-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .test-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(40, 167, 69, 0.3);
        }

        .test-btn.danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        }

        .test-btn.danger:hover {
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
        }

        .result {
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .result.success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .result.error {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .result.info {
            background: linear-gradient(135deg, #d1ecf1, #bee5eb);
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .team-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }

        .team-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .team-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .team-status.pending {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”§ æ¸…é™¤åŠŸèƒ½è¨ºæ–·å·¥å…·</h1>
            <p>å°ˆé–€æª¢æŸ¥ I çµ„å’Œ J çµ„æ¸…é™¤å•é¡Œ</p>
        </div>

        <div class="content">
            <!-- å–®ä¸€éšŠä¼æ¸¬è©¦ -->
            <div class="test-section">
                <h3>ğŸ¯ å–®ä¸€éšŠä¼æ¸…é™¤æ¸¬è©¦</h3>
                <p style="margin-bottom: 15px; color: #666;">
                    æ¸¬è©¦ç‰¹å®šéšŠä¼çš„æ¸…é™¤åŠŸèƒ½ï¼Œé‡é»æª¢æŸ¥ I çµ„å’Œ J çµ„
                </p>
                <button class="test-btn" onclick="testSingleTeam('I')">æ¸¬è©¦ I çµ„æ¸…é™¤</button>
                <button class="test-btn" onclick="testSingleTeam('J')">æ¸¬è©¦ J çµ„æ¸…é™¤</button>
                <button class="test-btn" onclick="testSingleTeam('A')">æ¸¬è©¦ A çµ„æ¸…é™¤ (å°ç…§)</button>
                <div id="singleResult" class="result info" style="display: none;"></div>
            </div>

            <!-- æ‰¹é‡æ¸…é™¤æ¸¬è©¦ -->
            <div class="test-section">
                <h3>ğŸš€ æ‰¹é‡æ¸…é™¤æ¸¬è©¦</h3>
                <p style="margin-bottom: 15px; color: #666;">
                    æ¸¬è©¦æ‰€æœ‰éšŠä¼çš„æ¸…é™¤åŠŸèƒ½ï¼Œä¸¦é¡¯ç¤ºè©³ç´°é€²åº¦
                </p>
                <button class="test-btn" onclick="testBatchClear()">æ¸¬è©¦æ‰¹é‡æ¸…é™¤ (æ…¢é€Ÿ)</button>
                <button class="test-btn danger" onclick="testFastClear()">æ¸¬è©¦å¿«é€Ÿæ¸…é™¤ (åŸç‰ˆ)</button>
                <div id="batchResult" class="result info" style="display: none;"></div>
                
                <div class="team-grid" id="teamStatus" style="display: none;">
                    <!-- éšŠä¼ç‹€æ…‹æœƒå‹•æ…‹å¡«å…¥ -->
                </div>
            </div>

            <!-- ç‹€æ…‹æª¢æŸ¥ -->
            <div class="test-section">
                <h3>ğŸ“Š ç•¶å‰ç‹€æ…‹æª¢æŸ¥</h3>
                <button class="test-btn" onclick="checkAllTeamsStatus()">æª¢æŸ¥æ‰€æœ‰éšŠä¼ç‹€æ…‹</button>
                <button class="test-btn" onclick="checkIJStatus()">é‡é»æª¢æŸ¥ Iã€J çµ„</button>
                <div id="statusResult" class="result info" style="display: none;"></div>
            </div>

            <!-- Google Sheets ç›´æ¥æ¸¬è©¦ -->
            <div class="test-section">
                <h3>ğŸ“‹ Google Sheets å¯«å…¥æ¸¬è©¦</h3>
                <p style="margin-bottom: 15px; color: #666;">
                    ç›´æ¥æ¸¬è©¦ Google Sheets çš„å¯«å…¥åŠŸèƒ½
                </p>
                <button class="test-btn" onclick="testDirectWrite('I')">ç›´æ¥å¯«å…¥ I çµ„</button>
                <button class="test-btn" onclick="testDirectWrite('J')">ç›´æ¥å¯«å…¥ J çµ„</button>
                <button class="test-btn danger" onclick="testDirectClear('I')">ç›´æ¥æ¸…é™¤ I çµ„</button>
                <button class="test-btn danger" onclick="testDirectClear('J')">ç›´æ¥æ¸…é™¤ J çµ„</button>
                <div id="directResult" class="result info" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        const API_ENDPOINT = 'https://weekly-large-calf.ngrok-free.app/webhook/bowling-score';

        // é¡¯ç¤ºçµæœ
        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.className = `result ${type}`;
            element.style.display = 'block';
            element.textContent = message;
        }

        // æ¸¬è©¦å–®ä¸€éšŠä¼æ¸…é™¤
        async function testSingleTeam(team) {
            showResult('singleResult', `æ­£åœ¨æ¸¬è©¦ ${team}çµ„ æ¸…é™¤åŠŸèƒ½...`, 'info');
            
            try {
                const rounds = ['ç¬¬ä¸€å±€', 'ç¬¬äºŒå±€'];
                let results = [];
                
                for (const round of rounds) {
                    const startTime = Date.now();
                    
                    const clearData = {
                        action: "upload",
                        team_name: team,
                        round: round,
                        score: 0,
                        members: 1,
                        timestamp: new Date().toISOString()
                    };

                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'ngrok-skip-browser-warning': 'true'
                        },
                        body: JSON.stringify(clearData)
                    });

                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    const responseText = await response.text();
                    
                    results.push({
                        team,
                        round,
                        success: response.ok,
                        status: response.status,
                        responseTime,
                        responseText: responseText.substring(0, 200)
                    });
                    
                    // å»¶é² 500ms
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                let resultMessage = `${team}çµ„ æ¸…é™¤æ¸¬è©¦çµæœ:\n`;
                resultMessage += `æ¸¬è©¦æ™‚é–“: ${new Date().toLocaleString()}\n\n`;
                
                results.forEach(result => {
                    resultMessage += `${result.team}çµ„ ${result.round}:\n`;
                    resultMessage += `- ç‹€æ…‹: ${result.success ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}\n`;
                    resultMessage += `- HTTP ç‹€æ…‹ç¢¼: ${result.status}\n`;
                    resultMessage += `- å›æ‡‰æ™‚é–“: ${result.responseTime}ms\n`;
                    resultMessage += `- å›æ‡‰å…§å®¹: ${result.responseText}\n\n`;
                });
                
                const allSuccess = results.every(r => r.success);
                showResult('singleResult', resultMessage, allSuccess ? 'success' : 'error');
                
            } catch (error) {
                showResult('singleResult', `âŒ ${team}çµ„ æ¸¬è©¦å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // æ¸¬è©¦æ‰¹é‡æ¸…é™¤ (æ…¢é€Ÿç‰ˆæœ¬)
        async function testBatchClear() {
            showResult('batchResult', 'æ­£åœ¨é€²è¡Œæ‰¹é‡æ¸…é™¤æ¸¬è©¦ (æ…¢é€Ÿç‰ˆæœ¬)...', 'info');
            
            const teamStatusDiv = document.getElementById('teamStatus');
            teamStatusDiv.style.display = 'grid';
            teamStatusDiv.innerHTML = '';
            
            try {
                const teams = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                const rounds = ['ç¬¬ä¸€å±€', 'ç¬¬äºŒå±€'];
                let results = [];
                
                // å‰µå»ºéšŠä¼ç‹€æ…‹é¡¯ç¤º
                teams.forEach(team => {
                    const statusDiv = document.createElement('div');
                    statusDiv.id = `status-${team}`;
                    statusDiv.className = 'team-status pending';
                    statusDiv.textContent = `${team}çµ„ ç­‰å¾…ä¸­`;
                    teamStatusDiv.appendChild(statusDiv);
                });
                
                for (let i = 0; i < teams.length; i++) {
                    const team = teams[i];
                    const statusDiv = document.getElementById(`status-${team}`);
                    statusDiv.textContent = `${team}çµ„ è™•ç†ä¸­...`;
                    statusDiv.className = 'team-status pending';
                    
                    let teamSuccess = true;
                    
                    for (const round of rounds) {
                        try {
                            const clearData = {
                                action: "upload",
                                team_name: team,
                                round: round,
                                score: 0,
                                members: 1,
                                timestamp: new Date().toISOString()
                            };

                            const response = await fetch(API_ENDPOINT, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    'ngrok-skip-browser-warning': 'true'
                                },
                                body: JSON.stringify(clearData)
                            });

                            results.push({
                                team,
                                round,
                                success: response.ok,
                                status: response.status
                            });
                            
                            if (!response.ok) {
                                teamSuccess = false;
                            }
                            
                        } catch (error) {
                            results.push({
                                team,
                                round,
                                success: false,
                                error: error.message
                            });
                            teamSuccess = false;
                        }
                        
                        // å»¶é² 300ms
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // æ›´æ–°éšŠä¼ç‹€æ…‹
                    statusDiv.textContent = `${team}çµ„ ${teamSuccess ? 'âœ…' : 'âŒ'}`;
                    statusDiv.className = `team-status ${teamSuccess ? 'success' : 'error'}`;
                    
                    // æ›´æ–°é€²åº¦
                    const progress = Math.round(((i + 1) / teams.length) * 100);
                    showResult('batchResult', `æ‰¹é‡æ¸…é™¤é€²è¡Œä¸­... ${progress}%\nå·²è™•ç†: ${team}çµ„`, 'info');
                }
                
                // çµ±è¨ˆçµæœ
                const successCount = results.filter(r => r.success).length;
                const totalCount = results.length;
                
                let resultMessage = `æ‰¹é‡æ¸…é™¤æ¸¬è©¦å®Œæˆ!\n`;
                resultMessage += `æˆåŠŸ: ${successCount}/${totalCount}\n`;
                resultMessage += `å®Œæˆæ™‚é–“: ${new Date().toLocaleString()}\n\n`;
                
                // é¡¯ç¤ºå¤±æ•—çš„é …ç›®
                const failures = results.filter(r => !r.success);
                if (failures.length > 0) {
                    resultMessage += `å¤±æ•—é …ç›®:\n`;
                    failures.forEach(f => {
                        resultMessage += `- ${f.team}çµ„ ${f.round}: ${f.error || f.status}\n`;
                    });
                }
                
                showResult('batchResult', resultMessage, failures.length === 0 ? 'success' : 'error');
                
            } catch (error) {
                showResult('batchResult', `âŒ æ‰¹é‡æ¸¬è©¦å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // æ¸¬è©¦å¿«é€Ÿæ¸…é™¤ (åŸç‰ˆæœ¬)
        async function testFastClear() {
            showResult('batchResult', 'æ­£åœ¨é€²è¡Œå¿«é€Ÿæ¸…é™¤æ¸¬è©¦ (åŸç‰ˆæœ¬)...', 'info');
            
            try {
                const teams = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                const rounds = ['ç¬¬ä¸€å±€', 'ç¬¬äºŒå±€'];
                let results = [];
                
                // åŒæ™‚ç™¼é€æ‰€æœ‰è«‹æ±‚ (åŸç‰ˆæœ¬çš„åšæ³•)
                const promises = [];
                
                for (const team of teams) {
                    for (const round of rounds) {
                        const clearData = {
                            action: "upload",
                            team_name: team,
                            round: round,
                            score: 0,
                            members: 1,
                            timestamp: new Date().toISOString()
                        };

                        const promise = fetch(API_ENDPOINT, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                                'ngrok-skip-browser-warning': 'true'
                            },
                            body: JSON.stringify(clearData)
                        }).then(response => ({
                            team,
                            round,
                            success: response.ok,
                            status: response.status
                        })).catch(error => ({
                            team,
                            round,
                            success: false,
                            error: error.message
                        }));
                        
                        promises.push(promise);
                    }
                }
                
                // ç­‰å¾…æ‰€æœ‰è«‹æ±‚å®Œæˆ
                results = await Promise.all(promises);
                
                // çµ±è¨ˆçµæœ
                const successCount = results.filter(r => r.success).length;
                const totalCount = results.length;
                
                let resultMessage = `å¿«é€Ÿæ¸…é™¤æ¸¬è©¦å®Œæˆ!\n`;
                resultMessage += `æˆåŠŸ: ${successCount}/${totalCount}\n`;
                resultMessage += `å®Œæˆæ™‚é–“: ${new Date().toLocaleString()}\n\n`;
                
                // æŒ‰éšŠä¼åˆ†çµ„é¡¯ç¤ºçµæœ
                const teamResults = {};
                results.forEach(r => {
                    if (!teamResults[r.team]) {
                        teamResults[r.team] = [];
                    }
                    teamResults[r.team].push(r);
                });
                
                Object.keys(teamResults).forEach(team => {
                    const teamSuccess = teamResults[team].every(r => r.success);
                    resultMessage += `${team}çµ„: ${teamSuccess ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}\n`;
                });
                
                showResult('batchResult', resultMessage, successCount === totalCount ? 'success' : 'error');
                
            } catch (error) {
                showResult('batchResult', `âŒ å¿«é€Ÿæ¸¬è©¦å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // æª¢æŸ¥æ‰€æœ‰éšŠä¼ç‹€æ…‹
        async function checkAllTeamsStatus() {
            showResult('statusResult', 'æ­£åœ¨æª¢æŸ¥æ‰€æœ‰éšŠä¼ç‹€æ…‹...', 'info');
            
            try {
                const requestData = {
                    action: "getRankings",
                    timestamp: new Date().toISOString()
                };

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    },
                    body: JSON.stringify(requestData)
                });

                const responseText = await response.text();
                let data;
                
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    throw new Error(`JSON è§£æå¤±æ•—: ${parseError.message}`);
                }
                
                if (data && data.rankings && Array.isArray(data.rankings)) {
                    const teams = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                    let result = `æ‰€æœ‰éšŠä¼ç‹€æ…‹æª¢æŸ¥:\næª¢æŸ¥æ™‚é–“: ${new Date().toLocaleString()}\n\n`;
                    
                    teams.forEach(team => {
                        const teamData = data.rankings.find(r => r.team_name === team);
                        if (teamData) {
                            result += `${team}çµ„:\n`;
                            result += `  ç¬¬ä¸€å±€: ${teamData.round1_score || 0} åˆ†\n`;
                            result += `  ç¬¬äºŒå±€: ${teamData.round2_score || 0} åˆ†\n`;
                            result += `  ç¸½åˆ†: ${teamData.total_score || 0} åˆ†\n`;
                            result += `  äººæ•¸: ${teamData.members || 0} äºº\n`;
                            result += `  ç¬¬ä¸€å±€æŠ•çƒæ–¹å¼: ${teamData.round1_style || 'æœªè¨­å®š'}\n`;
                            result += `  ç¬¬äºŒå±€æŠ•çƒæ–¹å¼: ${teamData.round2_style || 'æœªè¨­å®š'}\n\n`;
                        } else {
                            result += `${team}çµ„: ç„¡è³‡æ–™\n\n`;
                        }
                    });
                    
                    showResult('statusResult', result, 'success');
                } else {
                    showResult('statusResult', 'âŒ ç„¡æ³•ç²å–éšŠä¼ç‹€æ…‹è³‡æ–™', 'error');
                }
                
            } catch (error) {
                showResult('statusResult', `âŒ æª¢æŸ¥ç‹€æ…‹å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // é‡é»æª¢æŸ¥ Iã€J çµ„
        async function checkIJStatus() {
            showResult('statusResult', 'æ­£åœ¨é‡é»æª¢æŸ¥ Iã€J çµ„ç‹€æ…‹...', 'info');
            
            try {
                const requestData = {
                    action: "getRankings",
                    timestamp: new Date().toISOString()
                };

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    },
                    body: JSON.stringify(requestData)
                });

                const responseText = await response.text();
                let data = JSON.parse(responseText);
                
                if (data && data.rankings && Array.isArray(data.rankings)) {
                    let result = `Iã€J çµ„ç‹€æ…‹é‡é»æª¢æŸ¥:\næª¢æŸ¥æ™‚é–“: ${new Date().toLocaleString()}\n\n`;
                    
                    ['I', 'J'].forEach(team => {
                        const teamData = data.rankings.find(r => r.team_name === team);
                        result += `${team}çµ„è©³ç´°ç‹€æ…‹:\n`;
                        
                        if (teamData) {
                            result += `  âœ… åœ¨è³‡æ–™åº«ä¸­æ‰¾åˆ°è³‡æ–™\n`;
                            result += `  ç¬¬ä¸€å±€åˆ†æ•¸: ${teamData.round1_score || 0}\n`;
                            result += `  ç¬¬äºŒå±€åˆ†æ•¸: ${teamData.round2_score || 0}\n`;
                            result += `  ç¸½åˆ†: ${teamData.total_score || 0}\n`;
                            result += `  äººæ•¸: ${teamData.members || 0}\n`;
                            result += `  ç¬¬ä¸€å±€æŠ•çƒæ–¹å¼: ${teamData.round1_style || 'æœªè¨­å®š'}\n`;
                            result += `  ç¬¬äºŒå±€æŠ•çƒæ–¹å¼: ${teamData.round2_style || 'æœªè¨­å®š'}\n`;
                            result += `  ä¸Šå‚³æ™‚é–“: ${teamData.upload_time || 'æœªçŸ¥'}\n`;
                        } else {
                            result += `  âŒ åœ¨è³‡æ–™åº«ä¸­æ‰¾ä¸åˆ°è³‡æ–™\n`;
                            result += `  å¯èƒ½åŸå› : å¾æœªä¸Šå‚³éåˆ†æ•¸æˆ–è³‡æ–™è¢«æ¸…é™¤\n`;
                        }
                        result += `\n`;
                    });
                    
                    showResult('statusResult', result, 'success');
                } else {
                    showResult('statusResult', 'âŒ ç„¡æ³•ç²å–æ’åè³‡æ–™', 'error');
                }
                
            } catch (error) {
                showResult('statusResult', `âŒ æª¢æŸ¥ Iã€J çµ„å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // ç›´æ¥å¯«å…¥æ¸¬è©¦
        async function testDirectWrite(team) {
            showResult('directResult', `æ­£åœ¨æ¸¬è©¦ç›´æ¥å¯«å…¥ ${team}çµ„...`, 'info');
            
            try {
                const testData = {
                    action: "upload",
                    team_name: team,
                    round: "ç¬¬ä¸€å±€",
                    score: 999,
                    members: 4,
                    timestamp: new Date().toISOString()
                };

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    },
                    body: JSON.stringify(testData)
                });

                const responseText = await response.text();
                
                let result = `${team}çµ„ ç›´æ¥å¯«å…¥æ¸¬è©¦çµæœ:\n`;
                result += `ç‹€æ…‹: ${response.ok ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}\n`;
                result += `HTTP ç‹€æ…‹ç¢¼: ${response.status}\n`;
                result += `å›æ‡‰å…§å®¹: ${responseText}\n`;
                result += `æ¸¬è©¦æ™‚é–“: ${new Date().toLocaleString()}\n`;
                
                showResult('directResult', result, response.ok ? 'success' : 'error');
                
            } catch (error) {
                showResult('directResult', `âŒ ${team}çµ„ ç›´æ¥å¯«å…¥å¤±æ•—:\n${error.message}`, 'error');
            }
        }

        // ç›´æ¥æ¸…é™¤æ¸¬è©¦
        async function testDirectClear(team) {
            showResult('directResult', `æ­£åœ¨æ¸¬è©¦ç›´æ¥æ¸…é™¤ ${team}çµ„...`, 'info');
            
            try {
                const clearData = {
                    action: "upload",
                    team_name: team,
                    round: "ç¬¬ä¸€å±€",
                    score: 0,
                    members: 1,
                    timestamp: new Date().toISOString()
                };

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    },
                    body: JSON.stringify(clearData)
                });

                const responseText = await response.text();
                
                let result = `${team}çµ„ ç›´æ¥æ¸…é™¤æ¸¬è©¦çµæœ:\n`;
                result += `ç‹€æ…‹: ${response.ok ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}\n`;
                result += `HTTP ç‹€æ…‹ç¢¼: ${response.status}\n`;
                result += `å›æ‡‰å…§å®¹: ${responseText}\n`;
                result += `æ¸¬è©¦æ™‚é–“: ${new Date().toLocaleString()}\n`;
                
                showResult('directResult', result, response.ok ? 'success' : 'error');
                
            } catch (error) {
                showResult('directResult', `âŒ ${team}çµ„ ç›´æ¥æ¸…é™¤å¤±æ•—:\n${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
